// <auto-generated /> 
#nullable enable

using JMESPath;

public class Pipe
{

    [Theory]
    [InlineData(
"""
foo.*.baz | [0]
""",
"""
subkey
""")]
    [InlineData(
"""
foo.*.baz | [1]
""",
"""
subkey
""")]
    [InlineData(
"""
foo.*.baz | [2]
""",
"""
subkey
""")]
    [InlineData(
"""
foo.bar.* | [0]
""",
"""
subkey
""")]
    [InlineData(
"""
foo.*.notbaz | [*]
""",
"""
[
  [
    "a",
    "b",
    "c"
  ],
  [
    "a",
    "b",
    "c"
  ]
]
""")]
    [InlineData(
"""
{"a": foo.bar, "b": foo.other} | *.baz
""",
"""
[
  "subkey",
  "subkey"
]
""")]
    public void Test_1(string expression, string expectedResult)
    {
        // Arrange 
        string? given =
"""
{
  "foo": {
    "bar": {
      "baz": "subkey"
    },
    "other": {
      "baz": "subkey"
    },
    "other2": {
      "baz": "subkey"
    },
    "other3": {
      "notbaz": [
        "a",
        "b",
        "c"
      ]
    },
    "other4": {
      "notbaz": [
        "a",
        "b",
        "c"
      ]
    }
  }
}
""";

        // Act 
        string? result = JMESPathSearcher.Search(expression, given);
        
        // Assert
        Assert.Equal(result, expectedResult);
    }

    [Theory]
    [InlineData(
"""
foo | bar
""",
"""
{
  "baz": "one"
}
""")]
    [InlineData(
"""
foo | bar | baz
""",
"""
one
""")]
    [InlineData(
"""
foo|bar| baz
""",
"""
one
""")]
    [InlineData(
"""
not_there | [0]
""",
"""

""")]
    [InlineData(
"""
not_there | [0]
""",
"""

""")]
    [InlineData(
"""
[foo.bar, foo.other] | [0]
""",
"""
{
  "baz": "one"
}
""")]
    [InlineData(
"""
{"a": foo.bar, "b": foo.other} | a
""",
"""
{
  "baz": "one"
}
""")]
    [InlineData(
"""
{"a": foo.bar, "b": foo.other} | b
""",
"""
{
  "baz": "two"
}
""")]
    [InlineData(
"""
foo.bam || foo.bar | baz
""",
"""
one
""")]
    [InlineData(
"""
foo | not_there || bar
""",
"""
{
  "baz": "one"
}
""")]
    public void Test_2(string expression, string expectedResult)
    {
        // Arrange 
        string? given =
"""
{
  "foo": {
    "bar": {
      "baz": "one"
    },
    "other": {
      "baz": "two"
    },
    "other2": {
      "baz": "three"
    },
    "other3": {
      "notbaz": [
        "a",
        "b",
        "c"
      ]
    },
    "other4": {
      "notbaz": [
        "d",
        "e",
        "f"
      ]
    }
  }
}
""";

        // Act 
        string? result = JMESPathSearcher.Search(expression, given);
        
        // Assert
        Assert.Equal(result, expectedResult);
    }

    [Theory]
    [InlineData(
"""
foo[*].bar[*] | [0][0]
""",
"""
{
  "baz": "one"
}
""")]
    public void Test_3(string expression, string expectedResult)
    {
        // Arrange 
        string? given =
"""
{
  "foo": [
    {
      "bar": [
        {
          "baz": "one"
        },
        {
          "baz": "two"
        }
      ]
    },
    {
      "bar": [
        {
          "baz": "three"
        },
        {
          "baz": "four"
        }
      ]
    }
  ]
}
""";

        // Act 
        string? result = JMESPathSearcher.Search(expression, given);
        
        // Assert
        Assert.Equal(result, expectedResult);
    }

}