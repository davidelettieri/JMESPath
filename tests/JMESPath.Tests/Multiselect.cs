// <auto-generated /> 
#nullable enable

using JMESPath;

public class Multiselect
{

    [Theory]
    [InlineData(
"""
foo.{bar: bar}
""",
"""
{
  "bar": "bar"
}
""")]
    [InlineData(
"""
foo.{"bar": bar}
""",
"""
{
  "bar": "bar"
}
""")]
    [InlineData(
"""
foo.{"foo.bar": bar}
""",
"""
{
  "foo.bar": "bar"
}
""")]
    [InlineData(
"""
foo.{bar: bar, baz: baz}
""",
"""
{
  "bar": "bar",
  "baz": "baz"
}
""")]
    [InlineData(
"""
foo.{"bar": bar, "baz": baz}
""",
"""
{
  "bar": "bar",
  "baz": "baz"
}
""")]
    [InlineData(
"""
{"baz": baz, "qux\"": "qux\""}
""",
"""
{
  "baz": 2,
  "qux\u0022": 3
}
""")]
    [InlineData(
"""
foo.{bar:bar,baz:baz}
""",
"""
{
  "bar": "bar",
  "baz": "baz"
}
""")]
    [InlineData(
"""
foo.{bar: bar,qux: qux}
""",
"""
{
  "bar": "bar",
  "qux": "qux"
}
""")]
    [InlineData(
"""
foo.{bar: bar, noexist: noexist}
""",
"""
{
  "bar": "bar",
  "noexist": null
}
""")]
    [InlineData(
"""
foo.{noexist: noexist, alsonoexist: alsonoexist}
""",
"""
{
  "noexist": null,
  "alsonoexist": null
}
""")]
    [InlineData(
"""
foo.badkey.{nokey: nokey, alsonokey: alsonokey}
""",
"""

""")]
    [InlineData(
"""
foo.nested.*.{a: a,b: b}
""",
"""
[
  {
    "a": "first",
    "b": "second"
  },
  {
    "a": "first",
    "b": "second"
  },
  {
    "a": "first",
    "b": "second"
  }
]
""")]
    [InlineData(
"""
foo.nested.three.{a: a, cinner: c.inner}
""",
"""
{
  "a": "first",
  "cinner": "third"
}
""")]
    [InlineData(
"""
foo.nested.three.{a: a, c: c.inner.bad.key}
""",
"""
{
  "a": "first",
  "c": null
}
""")]
    [InlineData(
"""
foo.{a: nested.one.a, b: nested.two.b}
""",
"""
{
  "a": "first",
  "b": "second"
}
""")]
    [InlineData(
"""
{bar: bar, baz: baz}
""",
"""
{
  "bar": 1,
  "baz": 2
}
""")]
    [InlineData(
"""
{bar: bar}
""",
"""
{
  "bar": 1
}
""")]
    [InlineData(
"""
{otherkey: bar}
""",
"""
{
  "otherkey": 1
}
""")]
    [InlineData(
"""
{no: no, exist: exist}
""",
"""
{
  "no": null,
  "exist": null
}
""")]
    [InlineData(
"""
foo.[bar]
""",
"""
[
  "bar"
]
""")]
    [InlineData(
"""
foo.[bar,baz]
""",
"""
[
  "bar",
  "baz"
]
""")]
    [InlineData(
"""
foo.[bar,qux]
""",
"""
[
  "bar",
  "qux"
]
""")]
    [InlineData(
"""
foo.[bar,noexist]
""",
"""
[
  "bar",
  null
]
""")]
    [InlineData(
"""
foo.[noexist,alsonoexist]
""",
"""
[
  null,
  null
]
""")]
    public void Test_1(string expression, string expectedResult)
    {
        // Arrange 
        string? given =
"""
{
  "foo": {
    "bar": "bar",
    "baz": "baz",
    "qux": "qux",
    "nested": {
      "one": {
        "a": "first",
        "b": "second",
        "c": "third"
      },
      "two": {
        "a": "first",
        "b": "second",
        "c": "third"
      },
      "three": {
        "a": "first",
        "b": "second",
        "c": {
          "inner": "third"
        }
      }
    }
  },
  "bar": 1,
  "baz": 2,
  "qux\u0022": 3
}
""";

        // Act 
        string? result = JMESPathSearcher.Search(expression, given);
        
        // Assert
        Assert.Equal(result, expectedResult);
    }

    [Theory]
    [InlineData(
"""
foo.{bar:bar,baz:baz}
""",
"""
{
  "bar": 1,
  "baz": [
    2,
    3,
    4
  ]
}
""")]
    [InlineData(
"""
foo.[bar,baz[0]]
""",
"""
[
  1,
  2
]
""")]
    [InlineData(
"""
foo.[bar,baz[1]]
""",
"""
[
  1,
  3
]
""")]
    [InlineData(
"""
foo.[bar,baz[2]]
""",
"""
[
  1,
  4
]
""")]
    [InlineData(
"""
foo.[bar,baz[3]]
""",
"""
[
  1,
  null
]
""")]
    [InlineData(
"""
foo.[bar[0],baz[3]]
""",
"""
[
  null,
  null
]
""")]
    public void Test_2(string expression, string expectedResult)
    {
        // Arrange 
        string? given =
"""
{
  "foo": {
    "bar": 1,
    "baz": [
      2,
      3,
      4
    ]
  }
}
""";

        // Act 
        string? result = JMESPathSearcher.Search(expression, given);
        
        // Assert
        Assert.Equal(result, expectedResult);
    }

    [Theory]
    [InlineData(
"""
foo.{bar: bar, baz: baz}
""",
"""
{
  "bar": 1,
  "baz": 2
}
""")]
    [InlineData(
"""
foo.[bar,baz]
""",
"""
[
  1,
  2
]
""")]
    public void Test_3(string expression, string expectedResult)
    {
        // Arrange 
        string? given =
"""
{
  "foo": {
    "bar": 1,
    "baz": 2
  }
}
""";

        // Act 
        string? result = JMESPathSearcher.Search(expression, given);
        
        // Assert
        Assert.Equal(result, expectedResult);
    }

    [Theory]
    [InlineData(
"""
foo.{bar: bar.baz[1],includeme: includeme}
""",
"""
{
  "bar": {
    "common": "second",
    "two": 2
  },
  "includeme": true
}
""")]
    [InlineData(
"""
foo.{"bar.baz.two": bar.baz[1].two, includeme: includeme}
""",
"""
{
  "bar.baz.two": 2,
  "includeme": true
}
""")]
    [InlineData(
"""
foo.[includeme, bar.baz[*].common]
""",
"""
[
  true,
  [
    "first",
    "second"
  ]
]
""")]
    [InlineData(
"""
foo.[includeme, bar.baz[*].none]
""",
"""
[
  true,
  []
]
""")]
    [InlineData(
"""
foo.[includeme, bar.baz[].common]
""",
"""
[
  true,
  [
    "first",
    "second"
  ]
]
""")]
    public void Test_4(string expression, string expectedResult)
    {
        // Arrange 
        string? given =
"""
{
  "foo": {
    "bar": {
      "baz": [
        {
          "common": "first",
          "one": 1
        },
        {
          "common": "second",
          "two": 2
        }
      ]
    },
    "ignoreme": 1,
    "includeme": true
  }
}
""";

        // Act 
        string? result = JMESPathSearcher.Search(expression, given);
        
        // Assert
        Assert.Equal(result, expectedResult);
    }

    [Theory]
    [InlineData(
"""
reservations[*].instances[*].{id: id, name: name}
""",
"""
[
  [
    {
      "id": "id1",
      "name": "first"
    },
    {
      "id": "id2",
      "name": "second"
    }
  ],
  [
    {
      "id": "id3",
      "name": "third"
    },
    {
      "id": "id4",
      "name": "fourth"
    }
  ]
]
""")]
    [InlineData(
"""
reservations[].instances[].{id: id, name: name}
""",
"""
[
  {
    "id": "id1",
    "name": "first"
  },
  {
    "id": "id2",
    "name": "second"
  },
  {
    "id": "id3",
    "name": "third"
  },
  {
    "id": "id4",
    "name": "fourth"
  }
]
""")]
    [InlineData(
"""
reservations[].instances[].[id, name]
""",
"""
[
  [
    "id1",
    "first"
  ],
  [
    "id2",
    "second"
  ],
  [
    "id3",
    "third"
  ],
  [
    "id4",
    "fourth"
  ]
]
""")]
    public void Test_5(string expression, string expectedResult)
    {
        // Arrange 
        string? given =
"""
{
  "reservations": [
    {
      "instances": [
        {
          "id": "id1",
          "name": "first"
        },
        {
          "id": "id2",
          "name": "second"
        }
      ]
    },
    {
      "instances": [
        {
          "id": "id3",
          "name": "third"
        },
        {
          "id": "id4",
          "name": "fourth"
        }
      ]
    }
  ]
}
""";

        // Act 
        string? result = JMESPathSearcher.Search(expression, given);
        
        // Assert
        Assert.Equal(result, expectedResult);
    }

    [Theory]
    [InlineData(
"""
foo
""",
"""
[
  {
    "bar": [
      {
        "qux": 2,
        "baz": 1
      },
      {
        "qux": 4,
        "baz": 3
      }
    ]
  },
  {
    "bar": [
      {
        "qux": 6,
        "baz": 5
      },
      {
        "qux": 8,
        "baz": 7
      }
    ]
  }
]
""")]
    [InlineData(
"""
foo[]
""",
"""
[
  {
    "bar": [
      {
        "qux": 2,
        "baz": 1
      },
      {
        "qux": 4,
        "baz": 3
      }
    ]
  },
  {
    "bar": [
      {
        "qux": 6,
        "baz": 5
      },
      {
        "qux": 8,
        "baz": 7
      }
    ]
  }
]
""")]
    [InlineData(
"""
foo[].bar
""",
"""
[
  [
    {
      "qux": 2,
      "baz": 1
    },
    {
      "qux": 4,
      "baz": 3
    }
  ],
  [
    {
      "qux": 6,
      "baz": 5
    },
    {
      "qux": 8,
      "baz": 7
    }
  ]
]
""")]
    [InlineData(
"""
foo[].bar[]
""",
"""
[
  {
    "qux": 2,
    "baz": 1
  },
  {
    "qux": 4,
    "baz": 3
  },
  {
    "qux": 6,
    "baz": 5
  },
  {
    "qux": 8,
    "baz": 7
  }
]
""")]
    [InlineData(
"""
foo[].bar[].[baz, qux]
""",
"""
[
  [
    1,
    2
  ],
  [
    3,
    4
  ],
  [
    5,
    6
  ],
  [
    7,
    8
  ]
]
""")]
    [InlineData(
"""
foo[].bar[].[baz]
""",
"""
[
  [
    1
  ],
  [
    3
  ],
  [
    5
  ],
  [
    7
  ]
]
""")]
    [InlineData(
"""
foo[].bar[].[baz, qux][]
""",
"""
[
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8
]
""")]
    public void Test_6(string expression, string expectedResult)
    {
        // Arrange 
        string? given =
"""
{
  "foo": [
    {
      "bar": [
        {
          "qux": 2,
          "baz": 1
        },
        {
          "qux": 4,
          "baz": 3
        }
      ]
    },
    {
      "bar": [
        {
          "qux": 6,
          "baz": 5
        },
        {
          "qux": 8,
          "baz": 7
        }
      ]
    }
  ]
}
""";

        // Act 
        string? result = JMESPathSearcher.Search(expression, given);
        
        // Assert
        Assert.Equal(result, expectedResult);
    }

    [Theory]
    [InlineData(
"""
foo.[baz[*].bar, qux[0]]
""",
"""
[
  [
    "abc",
    "def"
  ],
  "zero"
]
""")]
    public void Test_7(string expression, string expectedResult)
    {
        // Arrange 
        string? given =
"""
{
  "foo": {
    "baz": [
      {
        "bar": "abc"
      },
      {
        "bar": "def"
      }
    ],
    "qux": [
      "zero"
    ]
  }
}
""";

        // Act 
        string? result = JMESPathSearcher.Search(expression, given);
        
        // Assert
        Assert.Equal(result, expectedResult);
    }

    [Theory]
    [InlineData(
"""
foo.[baz[*].[bar, boo], qux[0]]
""",
"""
[
  [
    [
      "a",
      "c"
    ],
    [
      "d",
      "f"
    ]
  ],
  "zero"
]
""")]
    public void Test_8(string expression, string expectedResult)
    {
        // Arrange 
        string? given =
"""
{
  "foo": {
    "baz": [
      {
        "bar": "a",
        "bam": "b",
        "boo": "c"
      },
      {
        "bar": "d",
        "bam": "e",
        "boo": "f"
      }
    ],
    "qux": [
      "zero"
    ]
  }
}
""";

        // Act 
        string? result = JMESPathSearcher.Search(expression, given);
        
        // Assert
        Assert.Equal(result, expectedResult);
    }

    [Theory]
    [InlineData(
"""
foo.[baz[*].not_there || baz[*].bar, qux[0]]
""",
"""
[
  [
    "a",
    "d"
  ],
  "zero"
]
""")]
    public void Test_9(string expression, string expectedResult)
    {
        // Arrange 
        string? given =
"""
{
  "foo": {
    "baz": [
      {
        "bar": "a",
        "bam": "b",
        "boo": "c"
      },
      {
        "bar": "d",
        "bam": "e",
        "boo": "f"
      }
    ],
    "qux": [
      "zero"
    ]
  }
}
""";

        // Act 
        string? result = JMESPathSearcher.Search(expression, given);
        
        // Assert
        Assert.Equal(result, expectedResult);
    }

    [Theory]
    [InlineData(
"""
[[*],*]
""",
"""
[
  null,
  [
    "object"
  ]
]
""")]
    public void Test_10(string expression, string expectedResult)
    {
        // Arrange 
        string? given =
"""
{
  "type": "object"
}
""";

        // Act 
        string? result = JMESPathSearcher.Search(expression, given);
        
        // Assert
        Assert.Equal(result, expectedResult);
    }

    [Theory]
    [InlineData(
"""
[[*]]
""",
"""
[
  []
]
""")]
    [InlineData(
"""
missing.{foo: bar}
""",
"""

""")]
    public void Test_11(string expression, string expectedResult)
    {
        // Arrange 
        string? given =
"""
[]
""";

        // Act 
        string? result = JMESPathSearcher.Search(expression, given);
        
        // Assert
        Assert.Equal(result, expectedResult);
    }

}